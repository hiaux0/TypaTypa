<div class="cell ${selected ? 'selected-cell' : ''}">
  <!-- Content -->
  <section
    ref="cellContentRef"
    class="content ${isEdit ? 'editing' : ''} ${isOverflown ? 'overflown' : ''}"
    css="width: ${isEdit ? getEditWidth : widthPxNew};"
    data-compute-width.bind="setWidthPx(cell, columnSettings?.colWidth, wholeRow.length, cell.colsToNextText, isEdit)"
  >
    <!-- Can:t remember why input and read-only were wrapped -->
    <!-- <template if.bind="cell.text"> </template> -->
    <div if.bind="isEdit" class="input-container editing">
      <vim-editor
        vim-state.bind="vimState"
        vim-editor-hooks.bind="vimEditorHooks"
        show-line-numbers.bind="false"
        value.two-way="textareaValue"
        mapping-by-mode.bind="finalMappingByMode"
      ></vim-editor>
    </div>

    <!--<input-->
    <!--  if.bind="isEdit"-->
    <!--  ref="contentInputRef"-->
    <!--  type="text"-->
    <!--  class="editing"-->
    <!--  value.bind="textareaValue"-->
    <!--  keydown.trigger="onKeyDown($event)"-->
    <!--  autosize="on-width-autosize.bind: onInputWidthChanged; use-width-of-container.bind: true;"-->
    <!--/>-->
    <template else>
      <pre if.bind="isOverflown && selected" class=" read-only overflown" css="width: ${overflownWidth};"
        >${cell.text}</pre
      >
      <pre else class="read-only">${cell.text}</pre>
    </template>
  </section>

  <!-- Selection -->
  <div if.bind="selected" class="selection"></div>

  <!-- Autocomplete -->
</div>

<!-- <template if.bind="column === 8 && row === 4"> ${isOverflown} ${selected} </template> -->
